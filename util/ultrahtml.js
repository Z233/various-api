var L$1 = 1, R$1 = 2, k$1 = 3, $$1 = 4; function X(t, n = {}, ...o) { let r = { type: 1, name: typeof t == "function" ? t.name : t, attributes: n || {}, children: o.map(e => typeof e == "string" ? { type: 2, value: O$1(String(e)) } : e), parent: void 0, loc: [] }; return typeof t == "function" && w$2(r, t), r } var S$1 = Symbol("Fragment"), _ = new Set(["area", "base", "br", "col", "embed", "hr", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr"]), g$1 = new Set(["script", "style"]), v$1 = /([\@\.a-z0-9_\:\-]*)\s*?=?\s*?(['"]?)([\s\S]*?)\2\s+/gim, i = /(?:<(\/?)([a-zA-Z][a-zA-Z0-9\:-]*)(?:\s([^>]*?))?((?:\s*\/)?)>|(<\!\-\-)([\s\S]*?)(\-\->)|(<\!)([\s\S]*?)(>))/gm; function M$1(t) { let n = {}, o; if (t) for (v$1.lastIndex = 0, t = " " + (t || "") + " "; o = v$1.exec(t);)o[0] !== " " && (n[o[1]] = o[3]); return n } function P(t) { let n = typeof t == "string" ? t : t.value, o, r, e, s, l, d, N, E, a, c = []; i.lastIndex = 0, r = o = { type: 0, children: [] }; let u = 0; function y() { s = n.substring(u, i.lastIndex - e[0].length), s && r.children.push({ type: 2, value: s, parent: r }); } for (; e = i.exec(n);) { if (d = e[5] || e[8], N = e[6] || e[9], E = e[7] || e[10], g$1.has(r.name) && e[2] !== r.name) { l = i.lastIndex - e[0].length, r.children.length > 0 && (r.children[0].value += e[0]); continue } else if (d === "<!--") { if (l = i.lastIndex - e[0].length, g$1.has(r.name)) continue; a = { type: 3, value: N, parent: r, loc: [{ start: l, end: l + d.length }, { start: i.lastIndex - E.length, end: i.lastIndex }] }, c.push(a), a.parent.children.push(a); } else if (d === "<!") l = i.lastIndex - e[0].length, a = { type: 4, value: N, parent: r, loc: [{ start: l, end: l + d.length }, { start: i.lastIndex - E.length, end: i.lastIndex }] }, c.push(a), a.parent.children.push(a); else if (e[1] !== "/") if (y(), g$1.has(r.name)) { u = i.lastIndex, y(); continue } else a = { type: 1, name: e[2] + "", attributes: M$1(e[3]), parent: r, children: [], loc: [{ start: i.lastIndex - e[0].length, end: i.lastIndex }] }, c.push(a), a.parent.children.push(a), e[4] && e[4].indexOf("/") > -1 || _.has(a.name) ? (a.loc[1] = a.loc[0], a.isSelfClosingTag = !0) : r = a; else y(), e[2] + "" === r.name ? (a = r, r = a.parent, a.loc.push({ start: i.lastIndex - e[0].length, end: i.lastIndex }), s = n.substring(a.loc[0].end, a.loc[1].start), a.children.length === 0 && a.children.push({ type: 2, value: s, parent: r })) : e[2] + "" === c[c.length - 1].name && c[c.length - 1].isSelfClosingTag === !0 && (a = c[c.length - 1], a.loc.push({ start: i.lastIndex - e[0].length, end: i.lastIndex })); u = i.lastIndex; } return s = n.slice(u), r.children.push({ type: 2, value: s, parent: r }), o } var h$1 = class h { constructor(n) { this.callback = n; } async visit(n, o, r) { if (await this.callback(n, o, r), Array.isArray(n.children)) { let e = []; for (let s = 0; s < n.children.length; s++) { let l = n.children[s]; e.push(this.visit(l, n, s)); } await Promise.all(e); } } }, m = class { constructor(n) { this.callback = n; } visit(n, o, r) { if (this.callback(n, o, r), Array.isArray(n.children)) for (let e = 0; e < n.children.length; e++) { let s = n.children[e]; this.visit(s, n, e); } } }, p$2 = Symbol("HTMLString"), b$2 = Symbol("AttrString"), x$1 = Symbol("RenderFn"); function f(t, n = [p$2]) { let o = { value: t }; for (let r of n) Object.defineProperty(o, r, { value: !0, enumerable: !1, writable: !1 }); return o } function w$2(t, n) { return Object.defineProperty(t, x$1, { value: n, enumerable: !1 }), t } var I$1 = { "&": "&amp;", "<": "&lt;", ">": "&gt;" }; function O$1(t) { return t.replace(/[&<>]/g, n => I$1[n] || n) } function T$1(t) { let n = ""; for (let [o, r] of Object.entries(t)) n += ` ${o}="${r}"`; return f(n, [p$2, b$2]) } function V(t, ...n) { let o = ""; for (let r = 0; r < t.length; r++) { o += t[r]; let e = n[r]; o.endsWith("...") && e && typeof e == "object" ? (o = o.slice(0, -3).trimEnd(), o += T$1(e).value) : e && e[b$2] ? (o = o.trimEnd(), o += e.value) : e && e[p$2] ? o += e.value : typeof e == "string" ? o += O$1(e) : (e || e === 0) && (o += String(e)); } return f(o) } function F$1(t, n) { return new h$1(n).visit(t) } function H(t, n) { return new m(n).visit(t) } async function C$1(t) { let { name: n, attributes: o = {} } = t, r = await Promise.all(t.children.map(e => D$1(e))).then(e => e.join("")); if (x$1 in t) { let e = await t[x$1](o, f(r)); return e && e[p$2] ? e.value : O$1(String(e)) } return n === S$1 ? r : _.has(n) ? `<${t.name}${T$1(o).value}>` : `<${t.name}${T$1(o).value}>${r}</${t.name}>` } async function D$1(t) { switch (t.type) { case 0: return Promise.all(t.children.map(n => D$1(n))).then(n => n.join("")); case 1: return C$1(t); case 2: return `${t.value}`; case 3: return `<!--${t.value}-->`; case 4: return `<!${t.value}>` } } async function U$1(t, n = []) { if (!Array.isArray(n)) throw new Error(`Invalid second argument for \`transform\`! Expected \`Transformer[]\` but got \`${typeof n}\``); let r = typeof t == "string" ? P(t) : t; for (let e of n) r = await e(r); return D$1(r) }

var b$1 = { attribute: /\[\s*(?:(?<namespace>\*|[-\w]*)\|)?(?<name>[-\w\u{0080}-\u{FFFF}]+)\s*(?:(?<operator>\W?=)\s*(?<value>.+?)\s*(?<caseSensitive>[iIsS])?\s*)?\]/gu, id: /#(?<name>(?:[-\w\u{0080}-\u{FFFF}]|\\.)+)/gu, class: /\.(?<name>(?:[-\w\u{0080}-\u{FFFF}]|\\.)+)/gu, comma: /\s*,\s*/g, combinator: /\s*[\s>+~]\s*/g, "pseudo-element": /::(?<name>[-\w\u{0080}-\u{FFFF}]+)(?:\((?<argument>¶+)\))?/gu, "pseudo-class": /:(?<name>[-\w\u{0080}-\u{FFFF}]+)(?:\((?<argument>¶+)\))?/gu, type: /(?:(?<namespace>\*|[-\w]*)\|)?(?<name>[-\w\u{0080}-\u{FFFF}]+)|\*/gu }, T = new Set(["pseudo-class", "pseudo-element"]), C = new Set([...T, "attribute"]), I = new Set(["combinator", "comma"]), E$1 = new Set(["not", "is", "where", "has", "matches", "-moz-any", "-webkit-any", "nth-child", "nth-last-child"]), M = { "nth-child": /(?<index>[\dn+-]+)\s+of\s+(?<subtree>.+)/ }; E$1["nth-last-child"] = M["nth-child"]; var w$1 = Object.assign({}, b$1); function R(t, r) { let e = "", n = []; for (; r < t.length; r++) { let s = t[r]; if (s === "(") n.push(s); else if (s === ")") { if (!(n.length > 0)) throw new Error("Closing paren without opening paren at " + r); n.pop(); } if (e += s, n.length === 0) return e } throw new Error("Opening paren without closing paren") } function k(t, r) { if (!t) return []; var e = [t]; for (var n in r) { let u = r[n]; for (var s = 0; s < e.length; s++) { var o = e[s]; if (typeof o == "string") { u.lastIndex = 0; var a = u.exec(o); if (a) { let l = a.index - 1, c = [], f = a[0], m = o.slice(0, l + 1); m && c.push(m), c.push({ type: n, content: f, ...a.groups }); let g = o.slice(l + f.length + 1); g && c.push(g), e.splice(s, 1, ...c); } } } } let i = 0; for (let u = 0; u < e.length; u++) { let l = e[u], c = l.length || l.content.length; typeof l == "object" && (l.pos = [i, i + c], I.has(l.type) && (l.content = l.content.trim() || " ")), i += c; } return e } function A(t) { if (!t) return null; t = t.trim(); let r = []; t = t.replace(/(['"])(\\\1|.)+?\1/g, (i, u, l, c) => (r.push({ str: i, start: c }), u + "\xA7".repeat(l.length) + u)); let e, n = [], s = 0; for (; (e = t.indexOf("(", s)) > -1;) { let i = R(t, e); n.push({ str: i, start: e }), t = t.substring(0, e) + "(" + "\xB6".repeat(i.length - 2) + ")" + t.substring(e + i.length), s = e + i.length; } let o = k(t, b$1); function a(i, u, l) { for (let c of i) for (let f of o) if (l.has(f.type) && f.pos[0] < c.start && c.start < f.pos[1]) { let m = f.content; if (f.content = f.content.replace(u, c.str), f.content !== m) { w$1[f.type].lastIndex = 0; let g = w$1[f.type].exec(f.content).groups; Object.assign(f, g); } } } return a(n, /\(¶+\)/, T), a(r, /(['"])§+?\1/, C), o } function N$1(t, { list: r = !0 } = {}) { if (r && t.find(e => e.type === "comma")) { let e = [], n = []; for (let s = 0; s < t.length; s++)if (t[s].type === "comma") { if (n.length === 0) throw new Error("Incorrect comma at " + s); e.push(N$1(n, { list: !1 })), n.length = 0; } else n.push(t[s]); if (n.length === 0) throw new Error("Trailing comma"); return e.push(N$1(n, { list: !1 })), { type: "list", list: e } } for (let e = t.length - 1; e >= 0; e--) { let n = t[e]; if (n.type === "combinator") { let s = t.slice(0, e), o = t.slice(e + 1); return { type: "complex", combinator: n.content, left: N$1(s), right: N$1(o) } } } return t.length === 0 ? null : t.length === 1 ? t[0] : { type: "compound", list: [...t] } } function p$1(t, r, e, n) { if (t) { if (t.type === "complex") p$1(t.left, r, e, t), p$1(t.right, r, e, t); else if (t.type === "compound") for (let s of t.list) p$1(s, r, e, t); else t.subtree && e && e.subtree && p$1(t.subtree, r, e, t); r(t, n); } } function y(t, { recursive: r = !0, list: e = !0 } = {}) { let n = A(t); if (!n) return null; let s = N$1(n, { list: e }); return r && p$1(s, o => { if (o.type === "pseudo-class" && o.argument && E$1.has(o.name)) { let a = o.argument, i = M[o.name]; if (i) { let u = i.exec(a); if (!u) return; Object.assign(o, u.groups), a = u.groups.subtree; } a && (o.subtree = y(a, { recursive: !0, list: !0 })); } }), s } function F(t, r) { return r = r || Math.max(...t) + 1, t[0] * r ** 2 + t[1] * r + t[2] } function x(t, { format: r = "array" } = {}) { let e = typeof t == "object" ? t : y(t, { recursive: !0 }); if (!e) return null; if (e.type === "list") { let s = 10, o = e.list.map(i => { let u = x(i); return s = Math.max(s, ...u), u }), a = o.map(i => F(i, s)); return o[function (i) { let u = i[0], l = 0; for (let c = 0; c < i.length; c++)i[c] > u && (l = c, u = i[c]); return i.length === 0 ? -1 : l }(a)] } let n = [0, 0, 0]; return p$1(e, s => { s.type === "id" ? n[0]++ : s.type === "class" || s.type === "attribute" ? n[1]++ : s.type === "type" && s.content !== "*" || s.type === "pseudo-element" ? n[2]++ : s.type === "pseudo-class" && s.name !== "where" && (E$1.has(s.name) && s.subtree ? x(s.subtree).forEach((o, a) => n[a] += o) : n[1]++); }), n } w$1["pseudo-element"] = RegExp(b$1["pseudo-element"].source.replace("(?<argument>\xB6+)", "(?<argument>.+?)"), "gu"), w$1["pseudo-class"] = RegExp(b$1["pseudo-class"].source.replace("(?<argument>\xB6+)", "(?<argument>.+)"), "gu"); function B(t) { return F(x(t)) } function K(t, r) { return d(r)(t, t.parent, v(t, t.parent)) } function G(t, r) { let e = d(r); try { return O(t, (n, s, o) => { let a = e(n, s, o); return a || !1 }, { single: !0 })[0] } catch (n) { if (n instanceof Error) throw n; return n } } function U(t, r) { let e = d(r); return O(t, (n, s, o) => { let a = e(n, s, o); return a || !1 }) } function O(t, r, e = { single: !1 }) { let n = []; return H(t, (s, o, a) => { if (!(s && s.type !== L$1) && r(s, o, a)) { if (e.single) throw s; n.push(s); } }), n } var L = t => { let { operator: r = "=" } = t; switch (r) { case "=": return (e, n) => e === n; case "~=": return (e, n) => e.split(/\s+/g).includes(n); case "|=": return (e, n) => e.startsWith(n + "-"); case "*=": return (e, n) => e.indexOf(n) > -1; case "$=": return (e, n) => e.endsWith(n); case "^=": return (e, n) => e.startsWith(n) }return (e, n) => !1 }, v = (t, r) => r == null ? void 0 : r.children.filter(e => e.type === L$1).findIndex(e => e === t), W = t => { let [r, e = "1", n = "0"] = /^\s*(?:(-?(?:\d+)?)n)?\s*\+?\s*(\d+)?\s*$/gm.exec(t) ?? []; e.length === 0 && (e = "1"); let s = Number.parseInt(e === "-" ? "-1" : e), o = Number.parseInt(n); return a => s * a + o }, D = (t, r) => (r == null ? void 0 : r.children.filter(e => e.type === L$1).pop()) === t, $ = (t, r) => (r == null ? void 0 : r.children.filter(e => e.type === L$1).shift()) === t, z = (t, r) => (r == null ? void 0 : r.children.filter(e => e.type === L$1).length) === 1, S = t => { switch (t.type) { case "type": return r => t.content === "*" ? !0 : r.name === t.name; case "class": return r => { var e, n; return (n = (e = r.attributes) == null ? void 0 : e.class) == null ? void 0 : n.split(/\s+/g).includes(t.name) }; case "id": return r => { var e; return ((e = r.attributes) == null ? void 0 : e.id) === t.name }; case "pseudo-class": switch (t.name) { case "global": return (...r) => d(y(t.argument))(...r); case "not": return (...r) => !S(t.subtree)(...r); case "is": return (...r) => d(t.subtree)(...r); case "where": return (...r) => d(t.subtree)(...r); case "root": return (r, e) => r.type === L$1 && r.name === "html"; case "empty": return r => r.type === L$1 && (r.children.length === 0 || r.children.every(e => e.type === R$1 && e.value.trim() === "")); case "first-child": return (r, e) => $(r, e); case "last-child": return (r, e) => D(r, e); case "only-child": return (r, e) => z(r, e); case "nth-child": return (r, e) => { let n = v(r, e) + 1; if (Number.isNaN(Number(t.argument))) switch (t.argument) { case "odd": return Math.abs(n % 2) == 1; case "even": return n % 2 === 0; default: { if (!t.argument) throw new Error("Unsupported empty nth-child selector!"); let s = W(t.argument), o = e == null ? void 0 : e.children.filter(i => i.type === L$1), a = v(r, e) + 1; for (let i = 0; i < o.length; i++) { let u = s(i); if (u > o.length) return !1; if (u === a) return !0 } return !1 } }return n === Number(t.argument) }; default: throw new Error(`Unhandled pseudo-class: ${t.name}!`) }case "attribute": return r => { let { caseSensitive: e, name: n, value: s } = t; if (!r.attributes) return !1; let o = Object.entries(r.attributes); for (let [a, i] of o) if (e === "i" && (s = n.toLowerCase(), i = a.toLowerCase()), a === n) { if (!s) return !0; if ((s[0] === '"' || s[0] === "'") && s[0] === s[s.length - 1] && (s = JSON.parse(s)), s) return L(t)(i, s) } return !1 }; default: throw new Error(`Unhandled selector: ${t.type}`) } }, d = t => { let r = typeof t == "string" ? y(t) : t; switch (r.type) { case "list": { let e = r.list.map(n => S(n)); return (n, s, o) => { for (let a of e) if (a(n, s)) return !0; return !1 } } case "compound": { let e = r.list.map(n => S(n)); return (n, s, o) => { for (let a of e) if (!a(n, s)) return !1; return !0 } } case "complex": { let { left: e, right: n, combinator: s } = r, o = d(e), a = d(n), i = new WeakSet; return (u, l, c = 0) => { if ((o(u) || l && i.has(l) && s === " ") && i.add(u), !a(u)) return !1; switch (s) { case " ": case ">": return l ? i.has(l) : !1; case "~": { if (!l) return !1; for (let f of l.children.slice(0, c)) if (i.has(f)) return !0; return !1 } case "+": { if (!l) return !1; let f = l.children.slice(0, c).filter(g => g.type === L$1); if (f.length === 0) return !1; let m = f[f.length - 1]; if (!m) return !1; if (i.has(m)) return !0 } default: return !1 } } } default: return S(r) } };

function p(t) { var n; if (t === void 0) return { allowElements: [], dropElements: ["script"], allowComponents: !1, allowCustomElements: !1, allowComments: !1 }; { let e = new Set([]); (n = t.allowElements) != null && n.includes("script") || e.add("script"); for (let o of t.dropElements ?? []) e.add(o); return { allowComponents: !1, allowCustomElements: !1, allowComments: !1, ...t, dropElements: Array.from(e) } } } function E(t) { return t.name.includes("-") ? "custom-element" : /[\_\$A-Z]/.test(t.name[0]) || t.name.includes(".") ? "component" : "element" } function w(t, n, e) { var o, l, r; return ((o = e.allowElements) == null ? void 0 : o.length) > 0 && e.allowElements.includes(t) ? "allow" : ((l = e.blockElements) == null ? void 0 : l.length) > 0 && e.blockElements.includes(t) ? "block" : ((r = e.dropElements) == null ? void 0 : r.length) > 0 && e.dropElements.find(s => s === t) || n === "component" && !e.allowComponents || n === "custom-element" && !e.allowCustomElements ? "drop" : "allow" } function b(t, n) { var o, l, r, s, u, m, c, d; let e = t.attributes; for (let i of Object.keys(t.attributes)) ((o = n.allowAttributes) == null ? void 0 : o[i]) && ((l = n.allowAttributes) == null ? void 0 : l[i].includes(t.name)) || ((s = (r = n.allowAttributes) == null ? void 0 : r[i]) == null ? void 0 : s.includes("*")) || (((u = n.dropAttributes) == null ? void 0 : u[i]) && ((m = n.dropAttributes) == null ? void 0 : m[i].includes(t.name)) || ((d = (c = n.dropAttributes) == null ? void 0 : c[i]) == null ? void 0 : d.includes("*"))) && delete e[i]; return e } function g(t, n, e) { let o = E(n), { name: l } = n, r = w(l, o, t); return r === "drop" ? () => { e.children = e.children.filter(s => s !== n); } : r === "block" ? () => { e.children = e.children.map(s => s === n ? s.children : s).flat(1); } : () => { n.attributes = b(n, t); } } function N(t) { let n = p(t); return e => { let o = []; H(e, (l, r) => { switch (l.type) { case L$1: { o.push(g(n, l, r)); return } default: return } }); for (let l of o) l(); return e } }

const COMMENT_NODE = k$1;
const DOCTYPE_NODE = $$1;
const DOCUMENT_NODE = $$1;
const ELEMENT_NODE = L$1;
const Fragment = S$1;
const RenderFn = x$1;
const TEXT_NODE = R$1;
const attrs = T$1;
const h = X;
const html = V;
const parse = P;
const render = D$1;
const transform = U$1;
const walk = F$1;
const walkSync = H;

const matches = K;
const querySelector = G;
const querySelectorAll = U;
const specificity = B;

const sanitize = N;

export { COMMENT_NODE, DOCTYPE_NODE, DOCUMENT_NODE, ELEMENT_NODE, Fragment, RenderFn, TEXT_NODE, attrs, h, html, matches, parse, querySelector, querySelectorAll, render, sanitize, specificity, transform, walk, walkSync };
